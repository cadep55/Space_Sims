<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Planet Orbit Viewer (Start + Target + Transfer)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #070b12; }
    #ui {
      position: absolute; top: 12px; left: 12px; z-index: 2;
      background: rgba(0,0,0,0.58); color: #fff;
      padding: 10px 12px; border-radius: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      width: 350px;
    }
    #ui b { font-weight: 650; }
    #ui label { display: block; font-size: 12px; opacity: 0.92; margin-top: 8px; }
    #ui select, #ui input[type="range"] { width: 100%; }
    #ui .row { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    #ui .row > div { font-size: 12px; opacity: 0.92; }
    #ui .small { font-size: 11px; opacity: 0.82; line-height: 1.25; margin-top: 6px; }
    #ui .divider { height: 1px; background: rgba(255,255,255,0.14); margin: 10px 0; }
    canvas { display: block; }
  </style>

  <!-- Allows import maps to work more broadly -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>

  <!-- Import map so OrbitControls can resolve `import ... from "three"` -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="ui">
    <div class="row">
      <div><b>Planet Orbits</b> (Start/Target/Transfer)</div>
      <div id="fps"></div>
    </div>

    <label>Starting orbit preset</label>
    <select id="startPreset">
      <option value="LEO100" selected>LEO 100 km (circular)</option>
      <option value="SSO600">Sun-synchronous ~600 km (circular)</option>
      <option value="Molniya">Molniya (typical)</option>
      <option value="GEO">GEO (circular)</option>
    </select>

    <label>Target orbit preset</label>
    <select id="targetPreset">
      <option value="GEO" selected>GEO (circular)</option>
      <option value="SSO600">Sun-synchronous ~600 km (circular)</option>
      <option value="Molniya">Molniya (typical)</option>
      <option value="LEO100">LEO 100 km (circular)</option>
    </select>

    <div class="divider"></div>

    <label><input id="showPlane" type="checkbox" checked /> Equatorial plane (disk + polar grid)</label>
    <label><input id="showAxes" type="checkbox" checked /> Axes (X/Y/Z)</label>

    <div class="divider"></div>

    <!-- BOTH options -->
    <label><input id="showTransfer" type="checkbox" checked /> Option 1: Show transfer ellipse + burns</label>
    <label><input id="animateTransfer" type="checkbox" checked /> Option 2: Animate Start → Transfer → Target</label>

    <label style="margin-top:10px;">Animation speed: <span id="spdVal">0.35</span></label>
    <input id="spd" type="range" min="0" max="2" step="0.01" value="0.35" />

    <div class="small">
      Earth radius = 1 scene unit. Start (gold), Target (cyan), Transfer (magenta).
      Burns are white markers at transfer perigee/apogee. Craft color matches its current phase.
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // ===== Earth constants (planet-centered) =====
    const R_EARTH_KM = 6378.137;
    const kmToScene = (km) => km / R_EARTH_KM;
    const deg2rad = (d) => d * Math.PI / 180;

    // ===== Scene =====
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x070b12, 3, 18);

    const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.01, 300);
    camera.position.set(3.2, 2.2, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 0, 0);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));
    const key = new THREE.DirectionalLight(0xffffff, 1.0);
    key.position.set(5, 8, 3);
    scene.add(key);

    // ===== Planet =====
    scene.add(new THREE.Mesh(
      new THREE.SphereGeometry(1, 64, 48),
      new THREE.MeshStandardMaterial({ color: 0x2d6cdf, roughness: 0.85, metalness: 0.0 })
    ));

    // ===== Equatorial plane (more visual) =====
    const eqDisk = new THREE.Mesh(
      new THREE.CircleGeometry(9, 128),
      new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.06, side: THREE.DoubleSide })
    );
    scene.add(eqDisk);

    const polarGrid = new THREE.PolarGridHelper(9, 24, 12, 128, 0xffffff, 0xffffff);
    polarGrid.material.transparent = true;
    polarGrid.material.opacity = 0.18;
    scene.add(polarGrid);

    const eqRing = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(makeCirclePoints(9, 256)),
      new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.35 })
    );
    scene.add(eqRing);

    function makeCirclePoints(radius, segments) {
      const pts = [];
      for (let i = 0; i <= segments; i++) {
        const t = (i / segments) * Math.PI * 2;
        pts.push(new THREE.Vector3(radius * Math.cos(t), radius * Math.sin(t), 0));
      }
      return pts;
    }

    const axes = new THREE.AxesHelper(2.2);
    axes.material.transparent = true;
    axes.material.opacity = 0.7;
    scene.add(axes);

    // ===== UI =====
    const ui = {
      startPreset: document.getElementById("startPreset"),
      targetPreset: document.getElementById("targetPreset"),
      showPlane: document.getElementById("showPlane"),
      showAxes: document.getElementById("showAxes"),
      showTransfer: document.getElementById("showTransfer"),
      animateTransfer: document.getElementById("animateTransfer"),
      spd: document.getElementById("spd"),
      spdVal: document.getElementById("spdVal"),
      fps: document.getElementById("fps")
    };

    ui.showPlane.addEventListener("change", () => {
      const v = ui.showPlane.checked;
      eqDisk.visible = v; polarGrid.visible = v; eqRing.visible = v;
    });
    ui.showAxes.addEventListener("change", () => axes.visible = ui.showAxes.checked);
    ui.spd.addEventListener("input", () => ui.spdVal.textContent = parseFloat(ui.spd.value).toFixed(2));

    // ===== Orbit math =====
    // r_eci = Rz(Ω) * Rx(i) * Rz(ω) * r_pf
    function rotateOrbitPoint(x, y, iRad, raanRad, argpRad) {
      let X = x, Y = y, Z = 0;

      // Rz(argp)
      const c3 = Math.cos(argpRad), s3 = Math.sin(argpRad);
      const x1 = c3 * X - s3 * Y;
      const y1 = s3 * X + c3 * Y;
      const z1 = Z;

      // Rx(i)
      const c1 = Math.cos(iRad), s1 = Math.sin(iRad);
      const x2 = x1;
      const y2 = c1 * y1 - s1 * z1;
      const z2 = s1 * y1 + c1 * z1;

      // Rz(raan)
      const c2 = Math.cos(raanRad), s2 = Math.sin(raanRad);
      const x3 = c2 * x2 - s2 * y2;
      const y3 = s2 * x2 + c2 * y2;
      const z3 = z2;

      return new THREE.Vector3(x3, y3, z3);
    }

    function positionOnOrbit(orbit, nuRad) {
      const a = kmToScene(orbit.a_km);
      const e = orbit.e;
      const iRad = deg2rad(orbit.i_deg);
      const raanRad = deg2rad(orbit.raan_deg);
      const argpRad = deg2rad(orbit.argp_deg);

      const p = a * (1 - e * e);
      const r = p / (1 + e * Math.cos(nuRad));
      const x = r * Math.cos(nuRad);
      const y = r * Math.sin(nuRad);
      return rotateOrbitPoint(x, y, iRad, raanRad, argpRad);
    }

    function buildOrbitLine(orbit, material, segments = 512) {
      const pts = [];
      for (let k = 0; k <= segments; k++) {
        const nu = (k / segments) * Math.PI * 2;
        pts.push(positionOnOrbit(orbit, nu));
      }
      return new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), material);
    }

    // ===== Presets (Earth-centered) =====
    function preset(name) {
      switch (name) {
        case "LEO100": {
          const alt = 100;
          return { a_km: R_EARTH_KM + alt, e: 0.0, i_deg: 28.5, raan_deg: 0.0, argp_deg: 0.0 };
        }
        case "GEO": {
          const alt = 35786;
          return { a_km: R_EARTH_KM + alt, e: 0.0, i_deg: 0.0, raan_deg: 0.0, argp_deg: 0.0 };
        }
        case "SSO600": {
          const alt = 600;
          return { a_km: R_EARTH_KM + alt, e: 0.0, i_deg: 98.0, raan_deg: 40.0, argp_deg: 0.0 };
        }
        case "Molniya": {
          return { a_km: 26600, e: 0.74, i_deg: 63.4, raan_deg: 20.0, argp_deg: 270.0 };
        }
        default:
          return preset("LEO100");
      }
    }

    // ===== Transfer helper (visual Hohmann-like between circular radii) =====
    function makeTransferOrbit(startOrbit, targetOrbit) {
      const r1_km = startOrbit.a_km;   // circular proxy
      const r2_km = targetOrbit.a_km;

      const a_t = 0.5 * (r1_km + r2_km);
      const e_t = Math.abs(r2_km - r1_km) / (r2_km + r1_km);

      // Choose a transfer plane for visualization:
      // if planes are similar -> use start plane, else blend for readability.
      const di = Math.abs(startOrbit.i_deg - targetOrbit.i_deg);
      const w = di < 5 ? 0.0 : 0.5;
      const i_deg = (1 - w) * startOrbit.i_deg + w * targetOrbit.i_deg;
      const raan_deg = (1 - w) * startOrbit.raan_deg + w * targetOrbit.raan_deg;

      return { a_km: a_t, e: e_t, i_deg, raan_deg, argp_deg: 0.0 };
    }

    // ===== Materials =====
    const startMat   = new THREE.LineBasicMaterial({ color: 0xffd54a, transparent: true, opacity: 0.95 });
    const targetMat  = new THREE.LineBasicMaterial({ color: 0x3fdcff, transparent: true, opacity: 0.95 });
    const transferMat= new THREE.LineBasicMaterial({ color: 0xff4fd8, transparent: true, opacity: 0.95 });

    let startLine = null, targetLine = null, transferLine = null;

    // Burns
    const burnGeo = new THREE.SphereGeometry(0.028, 14, 10);
    const burnMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const burn1 = new THREE.Mesh(burnGeo, burnMat);
    const burn2 = new THREE.Mesh(burnGeo, burnMat);
    scene.add(burn1, burn2);

    // Craft marker
    const craftMat = new THREE.MeshBasicMaterial({ color: 0xffd54a });
    const craft = new THREE.Mesh(new THREE.SphereGeometry(0.035, 16, 12), craftMat);
    scene.add(craft);

    // ===== Build / rebuild =====
    function rebuild() {
      const startOrbit = preset(ui.startPreset.value);
      const targetOrbit = preset(ui.targetPreset.value);
      const transferOrbit = makeTransferOrbit(startOrbit, targetOrbit);

      // Remove old
      if (startLine) scene.remove(startLine);
      if (targetLine) scene.remove(targetLine);
      if (transferLine) scene.remove(transferLine);

      // Add new
      startLine = buildOrbitLine(startOrbit, startMat);
      targetLine = buildOrbitLine(targetOrbit, targetMat);
      transferLine = buildOrbitLine(transferOrbit, transferMat);

      scene.add(startLine);
      scene.add(targetLine);
      scene.add(transferLine);

      // Burn markers at transfer perigee (nu=0) and apogee (nu=pi)
      burn1.position.copy(positionOnOrbit(transferOrbit, 0));
      burn2.position.copy(positionOnOrbit(transferOrbit, Math.PI));

      // Respect toggle for Option 1 overlay
      setTransferVisibility(ui.showTransfer.checked);

      // Scale plane to include GEO comfortably
      const rGEO = kmToScene(R_EARTH_KM + 35786);
      const planeRadius = Math.max(2.0, rGEO * 1.15);
      const s = planeRadius / 9;
      eqDisk.scale.set(s, s, 1);
      polarGrid.scale.set(s, s, 1);
      eqRing.scale.set(s, s, 1);

      return { startOrbit, targetOrbit, transferOrbit };
    }

    function setTransferVisibility(v) {
      if (transferLine) transferLine.visible = v;
      burn1.visible = v;
      burn2.visible = v;
    }

    ui.startPreset.addEventListener("change", () => { state = rebuild(); resetAnimation(); });
    ui.targetPreset.addEventListener("change", () => { state = rebuild(); resetAnimation(); });

    ui.showTransfer.addEventListener("change", () => setTransferVisibility(ui.showTransfer.checked));
    ui.animateTransfer.addEventListener("change", () => resetAnimation());

    let state = rebuild();
    ui.spdVal.textContent = parseFloat(ui.spd.value).toFixed(2);

    // ===== Animation (Option 2) =====
    // Start (coast) -> Transfer (0..pi) -> Target (coast)
    let phase = "START";
    let phaseT = 0;

    function resetAnimation() {
      phase = "START";
      phaseT = 0;
      craftMat.color.setHex(0xffd54a);
    }

    function updatePhase(dtReal) {
      const T1 = 6.0;   // seconds coasting on start
      const T2 = 10.0;  // seconds traversing transfer (0..pi)
      const T3 = 6.0;   // seconds coasting on target

      phaseT += dtReal;

      if (phase === "START" && phaseT >= T1) {
        phase = "TRANSFER"; phaseT = 0;
        craftMat.color.setHex(0xff4fd8);
        craft.position.copy(burn1.position); // snap to first burn
      } else if (phase === "TRANSFER" && phaseT >= T2) {
        phase = "TARGET"; phaseT = 0;
        craftMat.color.setHex(0x3fdcff);
        craft.position.copy(burn2.position); // snap to second burn
      } else if (phase === "TARGET" && phaseT >= T3) {
        phase = "START"; phaseT = 0;
        craftMat.color.setHex(0xffd54a);
      }

      return { T2 };
    }

    // ===== Render loop =====
    let lastT = performance.now();
    let nu = 0;

    // simple fps
    let fpsAcc = 0, fpsN = 0, fpsLast = performance.now();

    function animate(t) {
      requestAnimationFrame(animate);
      const dtReal = Math.min((t - lastT) / 1000, 0.05);
      lastT = t;

      controls.update();

      const spd = parseFloat(ui.spd.value);
      const omega = dtReal * (0.7 + 2.0 * spd); // anomaly rate scaler

      if (!ui.animateTransfer.checked) {
        // Only coast on start orbit
        nu = (nu + omega) % (Math.PI * 2);
        craftMat.color.setHex(0xffd54a);
        craft.position.copy(positionOnOrbit(state.startOrbit, nu));
      } else {
        // Start → Transfer → Target
        const { T2 } = updatePhase(dtReal);

        if (phase === "START") {
          nu = (nu + omega) % (Math.PI * 2);
          craft.position.copy(positionOnOrbit(state.startOrbit, nu));
        } else if (phase === "TRANSFER") {
          // map time fraction to nu: 0 -> pi (one transfer leg)
          const frac = Math.min(phaseT / T2, 1.0);
          const nuT = frac * Math.PI;
          craft.position.copy(positionOnOrbit(state.transferOrbit, nuT));
        } else {
          nu = (nu + omega) % (Math.PI * 2);
          craft.position.copy(positionOnOrbit(state.targetOrbit, nu));
        }
      }

      renderer.render(scene, camera);

      // fps
      fpsAcc += 1 / dtReal; fpsN++;
      if (t - fpsLast > 500) {
        ui.fps.textContent = `${Math.round(fpsAcc / fpsN)} fps`;
        fpsAcc = 0; fpsN = 0; fpsLast = t;
      }
    }

    animate(performance.now());

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
